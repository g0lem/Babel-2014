#version 330 core
#extension GL_EXT_gpu_shader4:enable



const int MAX_POINT_LIGHTS = 2;    



in vec2 UV;
in vec3 normals;
in vec3 worlds;



in mat3 TBN;
in vec4 eyePos;




out vec3 color;




struct BaseLight                                                                    
{
                                                                                   
    vec3 color;                                                                     
    float ambient_intensity;                                                         
    float diffuse_intensity;                                                         


};                                                                                  


                                                                                    
struct DirectionalLight                                                             
{   
                                                                                
    BaseLight Base;                                                                 
    vec3 direction;                                                                 

};  



struct Attenuation                                                                  
{   
                                                                                
    float Constant;                                                                 
    float Linear;                                                                   
    float Exp;                                                                      

};                                                                                  


                                                                                    
struct PointLight                                                                           
{   
                                                                                        
    BaseLight Base;                                                                         
    vec3 position;                                                                          
    Attenuation Atten;                                                                      

}; 




struct TextureAttributes
{


float diffuse_scale;
float detail_scale;
float diffuse_intensity;

};




struct FogAttributes
{


vec3 color;

float density;


};




uniform DirectionalLight InternalDirectionalLight;
uniform PointLight InternalPointLights[MAX_POINT_LIGHTS];


uniform sampler2D myTextureSampler;   
uniform sampler2DArray myTextureSampler2;
uniform sampler2DArray myTextureSampler3;



uniform TextureAttributes attributes[4];


uniform FogAttributes fog;   




vec3 CalcBumpedNormal()
{


	vec4 tile_sample = texture2D(myTextureSampler,UV);

    vec3 outputNormal = vec3(0,0,0);


	outputNormal += (2.0 * texture2DArray(myTextureSampler3,
	 vec3(UV*attributes[0].detail_scale,0)).xyz - vec3(1.0, 1.0, 1.0))* tile_sample.r;

	outputNormal += (2.0 * texture2DArray(myTextureSampler3,
	 vec3(UV*attributes[1].detail_scale,1)).xyz - vec3(1.0, 1.0, 1.0))* tile_sample.g;

	outputNormal += (2.0 * texture2DArray(myTextureSampler3,
	 vec3(UV*attributes[2].detail_scale,2)).xyz - vec3(1.0, 1.0, 1.0))* tile_sample.b;

	outputNormal += (2.0 * texture2DArray(myTextureSampler3,
	 vec3(UV*attributes[3].detail_scale,3)).xyz - vec3(1.0, 1.0, 1.0))* tile_sample.a;


    outputNormal = normalize(TBN*outputNormal);


    return outputNormal;
}

vec3 CalcInternalLight(BaseLight Light,vec3 light_direction,vec3 Normal)
{


    vec3 AmbientLight = Light.color * Light.ambient_intensity;


	float cosAlpha = max(0,dot(Normal,-light_direction));                               
	
	 
    vec3 DiffuseLight = Light.color * Light.diffuse_intensity * cosAlpha;                                                                                             
   

	return DiffuseLight + AmbientLight;

}

vec3 CalcDirectionalLight(vec3 Normal)                                                      
{   

                                                                                        
    return CalcInternalLight(InternalDirectionalLight.Base, InternalDirectionalLight.direction, Normal); 


}  

vec3 CalcPointLight(int Index, vec3 Normal)                                                 
{                             

                                                              
    vec3 LightDirection = worlds - InternalPointLights[Index].position;                         

    float Distance = length(LightDirection);                                                
    LightDirection = normalize(LightDirection);                                             
  
                                                                                            
    vec3 Color = CalcInternalLight(InternalPointLights[Index].Base, LightDirection, Normal);       
    float Attenuation =  InternalPointLights[Index].Atten.Constant +                               
                         InternalPointLights[Index].Atten.Linear * Distance +                      
                         InternalPointLights[Index].Atten.Exp * Distance * Distance;               

                                                                                           
    return Color / Attenuation;                                      
}

vec3 SetTerrainTiles()
{

  

	vec3 outputColor = vec3(0,0,0);



	
	vec4 tile_sample = texture2D(myTextureSampler,UV);

	
	outputColor += attributes[0].diffuse_intensity*texture2DArray(myTextureSampler2,
	vec3(UV*attributes[0].diffuse_scale,0)).rgb * tile_sample.r;

	outputColor += attributes[1].diffuse_intensity*texture2DArray(myTextureSampler2,
	vec3(UV*attributes[1].diffuse_scale,1)).rgb * tile_sample.g;

	outputColor += attributes[2].diffuse_intensity*texture2DArray(myTextureSampler2,
	vec3(UV*attributes[2].diffuse_scale,2)).rgb * tile_sample.b;

	outputColor += attributes[3].diffuse_intensity*texture2DArray(myTextureSampler2,
	vec3(UV*attributes[3].diffuse_scale,3)).rgb * tile_sample.a;




return outputColor;
} 

float getFogFactor(float density)
{



float fogCoord = abs(eyePos.z/eyePos.w);
return exp(-pow((density * fogCoord), 2.0));



}

void main(){



	vec3  Normal = normalize(normals);
	
	                                
    vec3 TotalLight = CalcDirectionalLight(Normal);                                         


								                                                            
    for (int i = 0 ; i < 0 ; i++) {                                           


        TotalLight += CalcPointLight(i, Normal);                                            

    }
	


	color = SetTerrainTiles() * TotalLight;



   color = mix(fog.color,color,getFogFactor(fog.density)) ;

 

}


